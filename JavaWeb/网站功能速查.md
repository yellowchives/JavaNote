1. 5秒后跳转到百度: 通过JS代码实现

   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title></title>
   </head>
   <body>
   <div id="div"></div>
   </body>
   <script>
       let num = 5;
       let div = document.getElementById("div");//js代码获取dom
       div.style.color="red"//JS为元素设置style
       div.style.fontSize="32px"
       div.style.textAlign='center'
      function show(){
           div.innerHTML = "倒计时:"+num+"秒";
           num--;
           if(num < 0){
               location.href="http://www.baidu.com"//倒计时归零后通过 location.href 跳转到新的页面
           }
       }
       setInterval(show,1000);//设置循环, 每秒钟执行一次
   </script>
   </html>
   ```
   
2. js对HTML表单进行验证

   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <title>Title</title>
   </head>
   <body>
   <form action="#" method="get">
       用户名:<input type="text" name="username" id="username"><span></span>
   </form>
   
   <script>
       let regex = /^[\u4e00-\u9fa5]{3,12}$/
       let username = document.getElementById("username")
       //文本框失去焦点时验证用户名是否合法
       username.onblur = () =>{
           if (username.value!=null) {
               if(!username.value.match(regex)){
                   let span = document.getElementsByTagName("span")[0];
                   span.innerHTML = "用户名不合法, 请输入3至12位中文"
                   span.style.color="red"
               }
   
           }
       }
   </script>
   </body>
   </html>
   ```

3. 请求转发和请求包含

   ```java
   /*
   无论是转发还是包含,首先都要获得一个RequestDispatcher对象
   通过此对象调用forward()就是转发
   调用include就是包含
   */
   
   @WebServlet("/rd1")
   public class RequestDemo1 extends HttpServlet {
       @Override
       protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
           System.out.println("demo1被访问了。。。");
           //获取派遣对象, 参数是另一个Servlet
   		RequestDispatcher requestDispatcher = req.getRequestDispatcher("/rd2");
   		
           //转发
           requestDispatcher.forward(req,resp);
           
           //包含
           requestDispatcher.include(req,resp);
       }
   }
   ```
   
4. 网页重定向
   有些垃圾网站一访问就会自动跳转到其他页面, 这个功能是通过 ServletResponse 实现的. 

   ```java
   /*
   1.设置重定向状态码: resp.setStatus(302);
   2.设置响应头Location: resp.setHeader("location","要重定向的uri");
   
   也可以两步合一: resp.sendRedirect("要重定向的uri");
   */
   @WebServlet("/requestRedirect")
   public class RequestRedirect extends HttpServlet {
       @Override
       protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
           //1.设置重定向状态码: resp.setStatus(302);
           resp.setStatus(302);
           //2.设置响应头Location: resp.setHeader("location","要重定向的uri");
           resp.setHeader("location","/servlet1");
   
           //也可以两步合一: resp.sendRedirect("要重定向的uri");
           //resp.sendRedirect("/servlet1");
       }
   }
   ```

5. 网页定时刷新并跳转
   设置响应头中的refresh即可. 

   ```java
   //登录成功后显示3秒后跳转会首页
   @WebServlet("/refreshDemo")
   public class RefreshDemo extends HttpServlet {
       @Override
       protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
           //2秒后刷新并跳转百度
           resp.setHeader("refresh","2;url=https://www.baidu.com");
           //或者这样: resp.setHeader("Refresh","2;URL=/demo/index.jsp");
           
           //每3秒刷新一次本页面，常见于购物网站显示库存
           resp.setHeader("refresh","3");
       }
   ```

6. 设置浏览器缓存

   ```java
   //没有缓存
   resp.setHeader("Cache-Control", "no-cache");
   resp.setDateHeader("expries",-1);
   resp.setHeader("Pragma", "No-cache");
   resp.setHeader("Pragma", "No-store");
   
   //设置缓存过期时间
   resp.setDateHeader("Expires",System.currentTimeMillis()+1*60*60*1000);
   resp.setHeader("Cache-Control","max-age=3600*24*30");
   ```

7. 文件下载

   ```java
   public class ResponseDemo8 extends HttpServlet {
   
       public void doGet(HttpServletRequest request, HttpServletResponse response)
               throws ServletException, IOException {
        
           //1.设置响应消息头
           response.setHeader("Content-Type", "application/octet-stream");//注意下载的时候，设置响应正文的MIME类型，用application/octet-stream
           response.setHeader("Content-Disposition", "attachment;filename=1.jpg");//告知浏览器以下载的方式打开
           
           //2.获取文件路径（绝对路径）
           ServletContext context = this.getServletContext();
           String filePath = context.getRealPath("/uploads/6.jpg");//通过文件的虚拟路径，获取文件的绝对路径
           //3.通过文件路径构建一个字节输入流
           InputStream in  = new FileInputStream(filePath);
           //合二为一: InputStream is = getServletContext().getResourceAsStream("/uploads/6.jpg");
           
           //4.使用响应对象的字节输出流输出
           OutputStream out = response.getOutputStream();
           int len = 0;
           byte[] by = new byte[1024];
           while((len = in.read(by)) != -1){
               out.write(by, 0, len);
           }
           in.close();
       }
   }
   ```

8. 设置404、500状态码的默认页面
   tomcat默认的错误页面不友好，我们需要手动写几个错误页面，然后在web.xml中配置。这样当发生了错误时就会跳转到我们写好的错误页面。
   404错误页面:

   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
   </head>
   <body>
       404 NOT FOUND 请检查你的网址
   </body>
   </html>
   ```

   web.xml配置:

   ```xml
   <error-page>
           <error-code>404</error-code>
           <location>/error/404.html</location>
   </error-page>
   <error-page>
           <error-code>500</error-code>
           <location>/error/500.html</location>
   </error-page>
   ```

9. 中文乱码问题:
   可以通过过滤器统一解决这个问题:

   ```java
   @WebFilter("/*")
   public class CharsetFilter implements Filter {
   
       @Override
       public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
           //1.类型转换
           HttpServletRequest request =  (HttpServletRequest)servletRequest;
           HttpServletResponse response = (HttpServletResponse)servletResponse;
           //2.设置字符集
           request.setCharacterEncoding("utf-8");
           response.setContentType("text/html;charset=utf-8");
   
           //3.放行
           filterChain.doFilter(servletRequest,servletResponse);
       }
   }
   ```

10. 设备适配
    为电脑、手机编写不同的网页，通过电脑和手机访问可以分别显示。关键是获取设备的user-agent. 

    ```java
    
    @WebFilter("/*")
    public class DeviceAdapterFilter implements Filter {
        
        @Override
        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
            HttpServletRequest req = (HttpServletRequest)servletRequest;
            HttpServletResponse resp = (HttpServletResponse)servletResponse;
    
            //获取请求uri。uri很简洁，没有前面的localhost:8080/虚拟路径，只有/index.html
            String uri = req.getRequestURI();
            //如果uri包含了desktop或者mobile就不用处理，直接放行
            if(uri.startsWith("/desktop")||uri.startsWith("/mobile")){
                filterChain.doFilter(servletRequest,servletResponse);
            }else{
                //读取user-agent，全部转为小写
                String ua = req.getHeader("user-agent").toLowerCase();
         
                if(ua.contains("android")||ua.contains("iphone")){
                    //生成新的uri
                    String targetURI = "/mobile"+uri;
                    //请求重定向
                    resp.sendRedirect(targetURI);
                }else{
                    String targetURI = "/desktop"+uri;
                    System.out.println("PC端设备正在访问，重新跳转uri："+targetURI);
                    resp.sendRedirect(targetURI);
                }
            }
        }
    }
    
    ```

11. 访问量统计
    整个网站共享一个 ServletContext, 可以通过它来保存访问量. 具体实现通过监听器.

