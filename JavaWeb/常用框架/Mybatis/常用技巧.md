## 手动实现dao层

```java
public class MybatisTest {

    @Test
    public void test1() throws IOException {
        //1.Resources工具类，配置文件的加载，把配置文件加载成字节输入流
        InputStream resourceAsStream = Resources.getResourceAsStream("sqlMapConfig.xml");
        //2.解析了配置文件，并创建了sqlSessionFactory工厂
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
        //3.生产sqlSession
        SqlSession sqlSession = sqlSessionFactory.openSession();// 默认开启一个事务，但是该事务不会自动提交
        //在进行增删改操作时，要手动提交事务
        //4.sqlSession调用方法：查询所有selectList  查询单个：selectOne 添加：insert  修改：update 删除：delete
        List<User> users = sqlSession.selectList("user.findAll");
        for (User user : users) {
            System.out.println(user);
        }
        sqlSession.close();

    }
}
```

## 代理方式实现dao层

```java
public class MybatisTest {

    @Test
    public void test1() throws IOException {
       InputStream resourceAsStream = Resources.getResourceAsStream("sqlMapConfig.xml");
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        //获取代理实现类。xml中的namespace必须是接口的全限定名
        IUserDao mapper = sqlSession.getMapper(IUserDao.class);
        List<User> all = mapper.findAll();

    }
}
```

## 注解开发

核心配置文件中引入的映射配置文件，改成扫描类或者扫描类所在的包：

```xml
<configuration>
    <mappers>
        <!--引入映射配置文件-->
        <mapper resource="UserMapper.xml"></mapper>
        <!--扫描使用注解的类-->
        <mapper class="org.example.dao.IUserDao"></mapper>
        <!--扫描使用注解的类所在的包-->
        <package name="org.example.dao"></package>
    </mappers>
</configuration>
```

## 获取插入数据自动生成的主键

## 结果集映射

`resultMap` 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC `ResultSets` 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 `resultMap` 能够代替实现同等功能的数千行代码。ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。

```xml
<select id="selectUsers" resultType="map">
  select id, username, hashedPassword
  from some_table
  where id = #{id}
</select>
```

上述语句只是简单地将所有的列映射到 `HashMap` 的键上，这由 `resultType` 属性指定。不过上面的情况很少使用，因为如果数据库的列名和PO的属性名一样时，mybatis可以自动将结果集映射到对象上，就像下面这样：

```xml
<select id="selectUsers" resultType="org.example.domain.User">
  select id, username, hashedPassword
  from some_table
  where id = #{id}
</select>
```

如果数据表的列名和PO属性名不一样，可以在 SELECT 语句中设置列别名（这是一个基本的 SQL 特性）来完成匹配：

```xml
<select id="selectUsers" resultType="org.example.domain.User">
  select
    user_id             as "id",
    user_name           as "userName",
    hashed_password     as "hashedPassword"
  from some_table
  where id = #{id}
</select>
```

上面的例子没有一个需要显式配置 `ResultMap`，但显式使用外部的 `resultMap` 可以提供更强大的功能，比如下面使用resultMap解决了列名不匹配的问题：

```xml
<resultMap id="userResultMap" type="org.example.domain.User">
  <id property="id" column="user_id" />
  <result property="username" column="user_name"/>
  <result property="password" column="hashed_password"/>
</resultMap>
```

然后在引用它的语句中设置 `resultMap` 属性就行了（注意我们去掉了 `resultType` 属性，他和resultMap不能共存）。比如：

```xml
<select id="selectUsers" resultMap="userResultMap">
  select user_id, user_name, hashed_password
  from some_table
  where id = #{id}
</select>
```

## 二级缓存整合 redis

二级缓存是放在 jvm 进程中共享的，一级缓存是一个 session 共享的。mybatis 先查二级缓存，再查一级缓存，最后查数据库。

最简单的实现分布式缓存的方法。缓存可以精确到语句。

启用二级缓存，分成3步：

1. 开启全局二级缓存配置：

```xml
<settings>
	<setting name="cacheEnabled" value="true"/>
</settings>
```

2. 在需要使用二级缓存的Mapper配置文件中添加标签：

```xml
<cache></cache>
```

3. 在具体的sql标签上配置：userCache 默认为 true，所以不想用二级缓存的手动设置为false

```xml
<select id="findById" resultMap="BaseMap" useCache="true">
	select * from user where id = #{id}
</select>
```



## 插件

mybatis 可以使用插件对4大核心组件进行拦截：

1. 执行器 Executor
2. SQL语法构建器 StatementHandler
3. 参数处理器 ParameterHandler
4. 结果集处理器 ResultHandler
