## 会话

**会话指的是的是一个客户端服务器之间连续发生的一系列请求和响应过程**，例如，一个用户在某网站上的整个购物过程就是一个会话。

当用户通过浏览器访问Web应用时，通常情况下，服务器需要对用户的状态进行跟踪。例如，用户在网站结算商品时，Web服务器必须根据请求用户的身份，找到该用户所购买的商品。在Web开发中，服务器跟踪用户信息的技术称为会话技术。在Servlet技术中，提供了两个用于保存会话数据的对象，分别是客户端会话技术：Cookie和服务器端会话技术：Session。

## Cookie

它是客户端浏览器的缓存文件，里面记录了客户浏览器访问网站的一些内容。同时，也是HTTP协议请求和响应消息头的一部分。

在现实生活中，当顾客在购物时，商城经常会赠送顾客一张会员卡，卡上记录用户的个人信息、消费额度和积分额度等。顾客一旦接受了会员卡，以后每次光临该商场时，都可以使用这张会员卡，商场也将根据会员卡上的消费记录计算会员的优惠额度和累加积分。在Web应用中，Cookie的功能类似于这张会员卡，当用户通过浏览器访问Web服务器时，服务器会给客户端发送一些信息，这些信息都保存在 Cookie 中。这样，当该浏览器再次访问服务器时，都会在请求头中将 Cookie 发送给服务器，方便服务器对浏览器做出正确的响应。

cookie作用

1. cookie一般用于存储少量的不太敏感的数据
2. **在不登录的情况下，完成服务器对客户端的身份识别**

工作原理

1. 浏览器向服务器发送请求。
2. 服务器创建Cookie对象，保存用户信息，服务器将Cookie对象发送给浏览器。
3. 浏览器以后再次向服务器发送请求 ，携带Cookie对象。
4. 服务器通过Cookie对象，区分不同浏览器。

### cookie的属性

| 属性名称 | 属性作用                 | 是否重要 |
| -------- | ------------------------ | -------- |
| name     | cookie的名称             | 必要属性 |
| value    | cookie的值（不能是中文） | 必要属性 |
| path     | cookie的路径             | 重要     |
| domain   | cookie的域名             | 重要     |
| maxAge   | cookie的生存时间。       | 重要     |
| version  | cookie的版本号。         | 不重要   |
| comment  | cookie的说明。           | 不重要   |

### 使用

1. 创建Cookie对象，绑定数据：new Cookie(String name, String value)
2. 发送Cookie对象：resp.addCookie(Cookie cookie)
3. 获取Cookie，拿到数据：Cookie[]  request.getCookies() 
   然后遍历，使用getValue()
4. Cookie常用方法
   ![](D:\Program Files\Typora\Java\image\epub_35449554_162.jpg)

- Cookie创建

  ```java
  //创建Cookie对象
  Cookie cookie = new Cookie("level","level1");
  //响应浏览器
  response.addCookie(cookie);
  ```

- Cookie获取

  ```java
  //获取cookie
  Cookie[] cookies = request.getCookies();
  for (Cookie cookie : cookies) {
      if("level".equals(cookie.getName())){
          System.out.println("cookie.getValue():" + cookie.getValue());
          break;
      }
  }
  ```

- Cookie修改

  ```java
  //创建同名cookie，进行覆盖
  Cookie cookie2 = new Cookie("level","level3");
  response.addCookie(cookie2);
  ```

### 细节

- Cookie有大小，个数限制。每个网站最多只能存20个cookie，且大小不能超过4kb。同时，所有网站的cookie总数不超过300个。

- Cookie的有效时间：当不设置maxAge时，使用的是浏览器的内存，当关闭浏览器之后，cookie将丢失。设置了此值，就会保存成缓存文件（值必须是大于0的, 以秒为单位）。设置cookie保存时间为一个月：`setMaxAge(60*60*24*30)`
    1. 正数：指定cookie存货的秒数
    2. 负数：默认值
    3. 0：删除cookie信息


- cookie能不能存中文：Cookie的name不支持中文，Cookie的value支持中文。但在Cookie中使用中文，需要设置字符集问题，比较繁琐，所以不建议使用中文，尽量使用英文。

- 如Cookie的value必须使用中文，代码如下：

    ```java
    //设置编码
    Cookie cookie2 = new Cookie("level", URLEncoder.encode("会员3","UTF-8"));
    response.addCookie(cookie2);
    //设置解码
    URLDecoder.decode(cookie.getValue(),"UTF-8");             
    ```
    
- cookie共享问题：默认情况：假设在一个tomcat服务器中，部署了多个web项目，这些项目的cookie不能共享

- 不同项目之间共享：使用setPath(String path)，设置cookie的获取范围。默认情况下，设置当前的虚拟目录，只有一个项目下的资源才可以共享cookie。如果要在不同项目间共享，可以将path设置为"/"

- 不同tomcat服务器间共享：setDomain(String path)，如果设置一级域名相同，那么多个服务器之间cookie可以共享。如：setDomain(".baidu.com")，那么tieba.baidu.com和news.baidu.com中cookie可以共享

- Cookie缺点：


    - Cookie的value是String，存储数据不灵活【Object】
    - Cookie数量过多时，会浪费【数据流量】
    - Cookie存储浏览器端，相对不安全。

### 案例：记住上一次访问时间

```java
/**
 在服务器中的Servlet判断是否有一个名为lastTime的cookie
 1. 有：不是第一次访问
 1. 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20
 2. 写回Cookie：lastTime=2018年6月10日11:50:01
 2. 没有：是第一次访问
 1. 响应数据：您好，欢迎您首次访问
 2. 写回Cookie：lastTime=2018年6月10日11:50:01
其实使用 session 的 getLastAccessedTime()更简单
 */

@WebServlet("/cookieTest")
public class CookieTest extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //设置响应的消息体的数据格式以及编码
        response.setContentType("text/html;charset=utf-8");

        //1.获取所有Cookie
        Cookie[] cookies = request.getCookies();
        boolean flag = false;//没有cookie为lastTime
        //2.遍历cookie数组
        if(cookies != null && cookies.length > 0){
            for (Cookie cookie : cookies) {
                //3.获取cookie的名称
                String name = cookie.getName();
                //4.判断名称是否是：lastTime
                if("lastTime".equals(name)){
                    //有该Cookie，不是第一次访问

                    flag = true;//有lastTime的cookie

                    //设置Cookie的value
                    //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie
                    Date date  = new Date();
                    SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
                    String str_date = sdf.format(date);
                    System.out.println("编码前："+str_date);
                    //URL编码
                    str_date = URLEncoder.encode(str_date,"utf-8");
                    System.out.println("编码后："+str_date);
                    cookie.setValue(str_date);
                    //设置cookie的存活时间
                    cookie.setMaxAge(60 * 60 * 24 * 30);//一个月
                    response.addCookie(cookie);

                    //响应数据
                    //获取Cookie的value，时间
                    String value = cookie.getValue();
                    System.out.println("解码前："+value);
                    //URL解码：
                    value = URLDecoder.decode(value,"utf-8");
                    System.out.println("解码后："+value);
                    response.getWriter().write("<h1>欢迎回来，您上次访问时间为:"+value+"</h1>");

                    break;

                }
            }
        }

        if(cookies == null || cookies.length == 0 || flag == false){
            //没有，第一次访问

            //设置Cookie的value
            //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie
            Date date  = new Date();
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
            String str_date = sdf.format(date);
            System.out.println("编码前："+str_date);
            //URL编码
            str_date = URLEncoder.encode(str_date,"utf-8");
            System.out.println("编码后："+str_date);

            Cookie cookie = new Cookie("lastTime",str_date);
            //设置cookie的存活时间
            cookie.setMaxAge(60 * 60 * 24 * 30);//一个月
            response.addCookie(cookie);

            response.getWriter().write("<h1>您好，欢迎您首次访问</h1>");
        }


    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        this.doPost(request, response);
    }
}

```

### 案例：7天免登陆

```html
<h2>7天免输入</h2>
<form action="${pageContext.request.contextPath}/CookieServlet?method=login" method="post">
    用户名：<input name="username" type="text" value="${cookie.username.value}" /><br />
    密&emsp;码：<input name="password" type="password" value="${cookie.password.value}" /><br />
    7天免输入:<input type="checkbox" name="ck" value="ck"><br />
    <input type="submit" value="提 交" />
</form>
```

```java
//获取请求参数
String username = request.getParameter("username");
String password = request.getParameter("password");
String ck = request.getParameter("ck");
System.out.println("ck = " + ck);
if(ck != null && !"".equals(ck)){
    //7天免输入[域中session]
    //创建Cookie对象,保存用户信息
    Cookie unCookie = new Cookie("username",username);
    Cookie pwdCookie = new Cookie("password",password);
    //持久化Cookie信息
    unCookie.setMaxAge(60*60*24*7);
    pwdCookie.setMaxAge(60*60*24*7);
    //响应浏览器
    response.addCookie(unCookie);
    response.addCookie(pwdCookie);
}
```



## Session

Cookie 技术可以将用户的信息保存在各自的浏览器中，并且可以在多次请求下实现数据的共享。但是，如果传递的信息比较多，使用Cookie技术显然会增大服务器端程序处理的难度，这时，可以使用Session技术。注意Session技术是cookie的拓展，建立在cookie的基础上。

原理：

1. 程序员来饼干店，买饼干
2. 店家在电脑中录入会员信息【手机号】，同时发送一张卡片给程序员【手机号】
3. 以后程序员再次来饼干店，买饼干。会携带卡片
4. 店家通过卡片，去电脑中查询会员信息，从而区分会员信息

- Session工作原理
  1. 浏览器发送请求【第一次调用(HttpServletRequest)request.getSession()】
  2. 服务器创建Session对象，同时会创建一个特殊的Cookie对象【name是：JSESSIONID】,将Cookie发送给浏览器。
  3. 以后浏览器再次请求服务器时，携带Cookie对象
  4. 服务器通过Cookie的value查找Session对象，通过Session区分不同用户信息。

- Session工作原理【扩展版本】
  1. 浏览器发送请求【不是第一次】：原则上不会再创建Session对象，会获取已创建Session对象。
  2. 判断是否可以获取Session对象的两个条件
     - 特殊Cookie是否存在
       - 不存在：返回2步骤，重新执行后续操作。
       - 存在：判断Session对象本身是否存在？【Session默认存活30分钟-空闲时间】
         - Session存在：直接使用
         - Session不存在：返回@2步骤，重新执行后续操作。

### 使用

1. 获取HttpSession对象：HttpSession session = request.getSession();
   jsp中：session是内置对象，直接使用。
2. 使用HttpSession对象：
   Object getAttribute(String name)  
   void setAttribute(String name, Object value)
   void removeAttribute(String name)  
3. 销毁Session
   void invalidate()

原理：当浏览器访问Web服务器时，Servlet容器就会创建一个Session对象和ID属性，将ID属性通过Cookie发送给客户端。当客户端后续访问服务器时，只要将ID传递给服务器，服务器就能判断出该请求是哪个客户端发送的，从而选择与之对应的Session对象为其服务。Session不出用户创建的，服务器自动完成。

### 细节

1. Session有效时间【空闲时间】

   - Session默认空闲时间为：30分钟

     tomcat->conf->web.xml

     ```xml
     <session-config>
        <session-timeout>30</session-timeout>
     </session-config>
     ```

   - 设置Session空闲时间

     1. 全局设置：web.xml中设置

     2. 局部设置

        - session.setMaxInactiveInterval(ss):单位秒，类型：int

          ss>0：在session空闲ss秒后，失效【销毁】。

          ss<=0：设置session永不失效。

2. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？
   默认情况下不是。如果需要，就持久化保存cookie和session。

   ```java
   HttpSession session = req.getSession();
   //1.先持久化Cookie
   /*Cookie c = new Cookie("JSESSIONID",seesion.getId());
   c.setMaxAge(60*60*24*7);
   resp.addCookie(c);*/
   for (Cookie cookie : request.getCookies()) {
       if("JSESSIONID".equals(cookie.getName())){
           //设置cookie存活时间
           cookie.setMaxAge(60*60*24*7);
           response.addCookie(cookie);
           break;
       }
   }
   //设置session的空闲时间
   session.setMaxInactiveInterval(60*60*24*7);
   ```

3. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？
   不是同一个。

4. session释放：

   1. Session对象空闲时间达到了目标设置的最大值，自动释放
   2. Session对象被强制失效：`session.invalidate();`
   3. Web应用卸载
   4. 服务器进程停止

5. session钝化和活化

   1. **Session钝化：**Session在一段时间内没有被使用或关闭服务器时，会将当前存在的Session对象及Session对象中的数据从内存**序列化**到磁盘的过程，称之为钝化。
   2. **Session活化：**Session被钝化后，服务器再次调用Session对象或重启服务器时，将Session对象及Session对象中的数据从磁盘**反序列化**到内存的过程，称之为活化。

   3. 注意：如需Session中的数据，一同序列化及反序列化时，数据必须支持序列化【implements Serializable】

### 案例：处理表单重复提交问题

- 表单重复提交的危害
  - 可重复注册，对数据库进行批处理攻击。（验证码已解决该问题）
  - 可重复提交已付款表单，用户支付一次订单费用，下了多个订单
  - 等待...
- 解决表单重复提交的步骤
  - 生成一个不可重复（全球唯一）的随机数(uuid)
  - 在提交表单前，将随机数(uuid)分别存放到表单内的隐藏域，和session域对象中
  - 发送“提交表单”请求
  - 判断是否提交表单，具体操作如下：
    - 分别获取隐藏域和session域中的uuid
    - 判断两个域中的数据是否相等
      - 相等：提交表单，**并将session域中的uuid移除**
      - 不等：不提交表单
- UUID
  - 定义：是一个32位16进制的随机数
  - 特点：全球唯一
  - 使用：java.util.UUID.randomUUID()

```JSP
<%
//生成一个UUID随机数
    String uuid = UUID.randomUUID().toString().replace("-","").toUpperCase();
//放到session中
    session.setAttribute("uuid",uuid);
%>
<h2>解决表单重复提交问题</h2>
<form action="${pageContext.request.contextPath}/SessionServlet?method=repLogin" method="post">
    <!-- 放到表单隐藏域中 -->
    <input type="hidden" name="uuid2" value="<%=uuid%>">
    用户名：<input name="username" type="text"  /><br />
    密&emsp;码：<input name="password" type="password" /><br />
    <input type="submit" value="提 交" />
</form>
```

```java
protected void repLogin(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //从隐藏域中获取uuid2
        String uuid2 = request.getParameter("uuid2");
        //从session域中获取uuid
        HttpSession session = request.getSession();
        Object uuid = session.getAttribute("uuid");
    
        if(uuid!=null && uuid.toString().equals(uuid2)){
            //提交表单
            System.out.println("提交表单！");
            //并将session域中的uuid移除，这样下次重复提交表单就不会进入if语句
            session.removeAttribute("uuid");
        }
        System.out.println("End!");
    }
```

