## 实现方式

### 使用数据库

> [Select for update使用详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/143866444)

```sql
# 悲观锁
begin;
select * from goods where id = 1 for update; # 获取id=1的行锁
update goods set stock = stock - 1 where id = 1;
commit;

# 乐观锁
begin;
select version from goods where id=1;
update goods set stock = stock -1 and version = oldversion + 1 where version = oldVersion;
commit
```

注意: 必须是 InnoDB 引擎, 必须开启事务, 明确指定id的时候, 获取的是行锁.

如果两个会话同时使用 `select ... for update where id = 1`查询, 未获取到锁的会话将被阻塞.

总结:

1. 优点: 简单方便
2.  确定: 并发量大时, 对数据库压力大
3. 建议: 作为锁的数据库与业务数据库分开

### 使用 redis

> [七种方案！探讨Redis分布式锁的正确使用姿势 - 掘金 (juejin.cn)](https://juejin.cn/post/6936956908007850014)

`set resource_name my_random_value NX PX 30000 ` 

my_random_value: 一般用 uuid 就行, 确保每个线程都不相同, 用于释放锁时的校验

NX: key 不存在时设置成功

PX: 自动失效时间, 防止代码出现异常, 忘记释放锁

释放锁使用 delete 命令.  释放锁时校验前面设置的随机数, 相同才能释放, 否则有可能释放了其他线程的锁. 比如线程 A 获取了锁, 结果执行时间过长, 锁已经过期了, 这样其他线程就能获取锁了, 所以当线程 A 释放锁的时候要先校验随机值是否相同.

### 使用 zookeeper
