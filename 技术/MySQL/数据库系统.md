## 关系型数据库设计理论

https://pdai.tech/md/db/sql/sql-db-theory-concept.html

https://blog.csdn.net/calcular/article/details/79332453

## 范式

https://mp.weixin.qq.com/s/wyt-0y3lEhewa2cpeILYSQ

第一范式：列是原子的。就是一个单元格一个值，不能拆分

第二范式：1. 要有主键；2. 非主键列都完全依赖于主键。在一些存在联合主键的表中，有些非主键列只依赖于联合主键的一部分，这种情况就不满足第二范式。

第三范式：非主键列完全依赖于主键，不能存在传递依赖。

开发中兼顾查询效率，增加冗余字段，可以违反第三范式

SQL支持几种连接条件：

1. 自然连接默认匹配多个关系中名称相同的属性，也可以使用 where 指定连接的条件
2. join-on 提供了一种在 from 子句中包含连接谓词的方式
3. join-using 提供了一种多表查询的简单方式，通过 using 指定的属性的取值需要相等

```sql
# 自然连接
SELECT *
from student, student_class
WHERE student.uid = student_class.student_id;

# 内连接，在from子句中包含连接谓词
SELECT *
from student
JOIN student_class
on student.uid = student_class.student_id;

# mysql不支持
SELECT *
from student
NATURAL JOIN
student_class
USING (student.uid, student_class.student_id);
```

## 事务

事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。

### ACID

1. 原子性（Atomicity)：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚可以用undo log来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
2. 隔离性（Isolation)：一个事务的执行不能被其他事务干扰，这通常使用锁来实现。当前数据库系统中都提供了一种粒度锁（granular lock）的策略，允许事务仅锁住一个实体对象的子集，以此来提高事务之间的并发度。
3. 持久性（Duration)：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
4. 一致性（Consistency)：一致性指事务执行前后，数据从一个合法的状态转变为另一个合法的状态。这里合法的状态和业务有关。例如，在表中有一个字段为姓名，它是一个唯一约束，即在表中姓名不能重复。如果一个事务对表进行了修改，但是在事务提交或当事务操作发生回滚后，表中的数据姓名变得非唯一了，那么就破坏了事务的一致性要求。因此，事务是一致性的单位，如果事务中某个动作失败了，系统可以自动地撤销事务使其返回初始化的状态。

事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系:

- 只有满足一致性，事务的执行结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对数据库崩溃的情况。

![](数据库系统.assets/a58e294a-615d-4ea0-9fbf-064a6daec4b2.png)

### MVVC

https://mp.weixin.qq.com/s/bM_g6Z0K93DNFycvfJIbwQ

https://blog.csdn.net/dududxt/article/details/80854283

### 调度

用下面的方式代表一次事务：

```
1. R(A);
2. A = A - 10000;
3. W(A);
4. R(B);
5. B = B + 10000;
6. W(B);
```

When multiple transactions are running concurrently then there needs to be a sequence in which the operations are performed because at a time only one operation can be performed on the database. This sequence of operations is known as **Schedule**.

Here we have two transactions T1 & T2 which are running concurrently. In this example, all the instructions of transaction T1 are executed before the instructions of transaction T2. 

```
T1	T2
----    ----
R(X)	
W(X)	
R(Y)	
        R(Y)
        R(X)
        W(Y)
```

**调度类型**

1. 串行调度（Serial Schedule）：一个事务执行完成后才开始另一个事务。

2. 严格调度（Strict Schedule）：直到最后一个写数据项X的事务提交之前，其他事务都不能读或写X。可以证明，严格调度的最终结果等价于串行调度。

### 隔离级别

读未提交（read uncommitted）：一个事务的修改，就算没有提交，其他事务也是可见到。

读已提交（read committed）：一个事务所做的修改在提交之前对其它事务是不可见的。事务T1对数据做了更新，提交之后，T2再去查询就会发现数据已经改变了。

可重复读（repeatable read）：保证在同一个事务中多次读取同样数据的结果是一样的。MySQL默认。事务T1对数据做了更新，提交之后，T2再去查询发现数据还是不变。如果T2提交了，再开启一个新事务，去查询刚才的数据才能看到刚刚 T1 所做的改变。

可串行化（serializable）：强制事务串行执行。

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| 读未提交 | √    | √          | √    |
| 读已提交 |      | √          | √    |
| 可重复读 |      |            | √    |
| 串行化   |      |            |      |

以上所有隔离级别都不允许脏写，即如果一个数据项已经被另外一个尚未提交或中止的事务写过，则不允许对该数据项再执行写操作。

### 传播性

事务传播行为是为了解决业务层方法之间互相调用的事务问题，当一个事务方法被另一个事务方法调用时，事务该以何种状态存在？例如新方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行，等等，这些规则就涉及到事务的传播性。

关于事务的传播性，Spring 主要定义了如下几种：

| 传播性           | 描述                                                         |
| :--------------- | :----------------------------------------------------------- |
| REQUIRED（默认） | 如果当前有事务，则加入该事务；如果当前没有事务，则创建一个新的事务 |
| SUPPORTS         | 如果当前有事务，则加入该事务；如果当前没有事务，则以非事务的方式运行 |
| MANDATORY        | 如果当前有事务，则加入该事务；如果当前没有事务，则抛出异常   |
| REQUIRES_NEW     | 如果当前存在事务，则把当前事务挂起。创建自己的新事物         |
| NOT_SUPPORTED    | 如果当前存在事务，则把当前事务挂起。自己以非事务运行。       |
| NEVER            | 以非事务方式运行，如果当前存在事务，则抛出异常               |
| NESTED           | 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务；如果当前没有事务，则该取值等价于 REQUIRED |

[长文捋明白 Spring 事务！隔离性？传播性？一网打尽！ - 江南一点雨 (javaboy.org)](http://www.javaboy.org/2021/1026/spring_transaction.html)

[6种 @Transactional 注解失效场景 - FrankYou - 博客园 (cnblogs.com)](https://www.cnblogs.com/frankyou/p/12691463.html)

一句话说明：

1. REQUIRED：领导有饭吃，会分给我吃。领导没饭吃，我有钱就自己吃。
2. SUPPORTS：领导有饭吃，会分给我吃。领导没饭吃，我也没饭吃。
3. REQUIRES_NEW：领导有饭吃，我偏要自己买自己吃
4. NESTED：嵌套事务的意思是，外层回滚则内层也要回滚；内层出现异常回滚，外层不用回滚（前提是内层的异常被处理了）。
   领导犯错，我也受罚。我犯错了 ，领导没事。
