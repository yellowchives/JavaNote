## JVM架构模型

JVM采用的是基于栈的指令集，编译后的指令数更多，但是更容易跨平台。

**基于栈的指令集**：

1. 设计和实现更简单，适用于资源受限的系统
2. 避开了寄存器的分配难题：使用零地址指令方式分配
3. 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现
4. 不需要硬件支持，可移植性更好，更好实现跨平台

**基于寄存器架构的特点：**

1. 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。
2. 指令集架构则完全依赖硬件，与硬件的耦合度高，可移植性差
3. 性能优秀和执行更高效
4. 花费更少的指令去完成一项操作
5. 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主

```java
public class StackStructTest {
    public static void main(String[] args) {
        //Java编译后指令集是基于栈的指令集，和c语言那种基于寄存器的不同
        int i = 1;
        int j = 2;
        int k = i + j;
    }
}

```

编译上面的 Java 文件，然后使用`javap -v StackStructTest.class `反编译，输出：

```
0: iconst_1
1: istore_1
2: iconst_2
3: istore_2
4: iload_1
5: iload_2
6: iadd
7: istore_3
8: return
```

如果是C语言，编译后类似：

```
mov eax 1
add eax 2
```

## JVM生命周期



