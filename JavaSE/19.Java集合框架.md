# Java集合框架

容器，就是可以容纳其他Java对象的对象。Java容器里只能放对象，对于基本类型(int, long, float, double等)，需要将其包装成对象类型后(Integer, Long, Float, Double等)才能放到容器里。

集合提供一种存储空间可变的存储模型，存储的数据容量可以改变。按照数据的组成可以分为单列集合和双列集合，按照元素能否重复分为可重复集合与不可重复集合。Java提供了多种接口来帮助实现不同的集合需求。  
![334190970_1568705196598_5712E31C0DD632882CA35FC6B748EEE5](19.Java集合框架.assets/334190970_1568705196598_5712E31C0DD632882CA35FC6B748EEE5.jpg)

从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。

集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：

- **接口：**是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象
- **实现（类）：**是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。
- **算法：**是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。

除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。

## 集合接口

集合框架定义了一些接口。本节提供了每个接口的概述：

| 序号 |                           接口描述                           |
| :--: | :----------------------------------------------------------: |
|  1   | Collection 接口 Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。Collection 接口存储一组不唯一，无序的对象。 |
|  2   | List 接口 List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。List 接口存储一组不唯一，有序（插入顺序）的对象。 |
|  3   | Set Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。Set 接口存储一组唯一，无序的对象。 |
|  4   |             SortedSet 继承于Set保存有序的集合。              |
|  5   | Map Map 接口存储一组键值对象，提供key（键）到value（值）的映射。 |
|  6   | Map.Entry 描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。 |
|  7   |        SortedMap 继承于 Map，使 Key 保持在升序排列。         |
|  8   | Enumeration 这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。 |

### Set和List的区别

- Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。
- Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 **(实现类有HashSet,TreeSet)**。
- List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 **(实现类有ArrayList,LinkedList,Vector)** 。

## Collection接口

| 方法名                     | 说明                               |
| -------------------------- | ---------------------------------- |
| boolean add(E e)           | 添加元素                           |
| boolean remove(Object o)   | 从集合中移除指定的元素             |
| void clear()               | 清空集合中的元素                   |
| boolean contains(Object o) | 判断集合中是否存在指定的元素       |
| boolean isEmpty()          | 判断集合是否为空                   |
| int size()                 | 集合的长度，也就是集合中元素的个数 |

### 集合布尔运算

1. A.containsAll(B); 如果A包含集合B的所有元素，返回true
2. A.removeAll(B); A集合变成了 A-B
3. A.retainAll(B); A集合变成了A和B的交集
4. A.addAll(B); A集合变成了A和B的并集

## List接口

| 方法名                                     | 描述                                         |
| ------------------------------------------ | -------------------------------------------- |
| void add(int index,E element)              | 在此集合中的指定位置插入指定的元素           |
| E remove(int index)                        | 删除指定索引处的元素，返回被删除的元素       |
| boolean remove(Object o)                   | 删除制定的元素，如果此元素重复，只删除第一个 |
| E set(int index,E element)                 | 修改指定索引处的元素，返回被修改的元素       |
| E get(int  index)                          | 返回指定索引处的元素                         |
| default void sort(Comparator<? super E> c) | 根据指定的外部排序器排序列表                 |

```java
package CollectionDemo;

import java.util.ArrayList;
import java.util.List;

public class ListTest {
    public static void main(String[] args) {
        List<String> li = new ArrayList<String>();
        li.add("Hello");
        li.add("World");
        li.add("Java");

        li.remove(0);//这是List类的特有方法
        li.remove("Java");//此方法继承自Collection类
        System.out.println(li);

        li.clear();
        li.add("World");
        li.add(0,"Hello");
        System.out.println(li);
    }
}
/*console：
[World]
[Hello, World]
/
```

### 实现类

- ArrayList集合

  ​	底层是数组结构实现，查询快、增删慢

- LinkedList集合

  ​	底层是链表结构实现，查询慢、增删快

### ArrayList

- ArrayList集合的特点

  ​	底层是数组实现的，长度可以变化

- 泛型的使用

  ​	用于约束集合中存储元素的数据类型

| 方法名                                  | 说明                                   |
| --------------------------------------- | -------------------------------------- |
| public boolean  remove(Object o)        | 删除指定的元素，返回删除是否成功       |
| public E  remove(int  index)            | 删除指定索引处的元素，返回被删除的元素 |
| public E  set(int index,E   element)    | 修改指定索引处的元素，返回被修改的元素 |
| public E  get(int   index)              | 返回指定索引处的元素                   |
| public int  size()                      | 返回集合中的元素的个数                 |
| public boolean  add(E e)                | 将指定的元素追加到此集合的末尾         |
| public void  add(int index,E   element) | 在此集合中的指定位置插入指定的元素     |
| public Object[] toArray                 | 返回一个数组                           |

```java
public class ArrayListDemo02 {
    public static void main(String[] args) {
        //创建集合，用到了泛型
        ArrayList<String> array = new ArrayList<String>();
        //可以把初始大小传给ArrayList：new ArrayList<>(100); 或者 array.ensureCapacity(100);

        //添加元素
        array.add("hello");
        array.add("world");
        array.add("java");

        //public boolean remove(Object o)：删除指定的元素，返回删除是否成功
//        System.out.println(array.remove("world"));
//        System.out.println(array.remove("javaee"));

        //public E remove(int index)：删除指定索引处的元素，返回被删除的元素
//        System.out.println(array.remove(1));

        //IndexOutOfBoundsException
//        System.out.println(array.remove(3));

        //public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素
//        System.out.println(array.set(1,"javaee"));

        //IndexOutOfBoundsException
//        System.out.println(array.set(3,"javaee"));

        //public E get(int index)：返回指定索引处的元素
//        System.out.println(array.get(0));
//        System.out.println(array.get(1));
//        System.out.println(array.get(2));
        //System.out.println(array.get(3)); //？？？？？？ 自己测试
        
        //一旦确定了数组列表的大小不再变了，就可以将多余的空间回收
        //array.trimT

        //public int size()：返回集合中的元素的个数
        System.out.println(array.size());

        //输出集合
        System.out.println("array:" + array);
    }
}
```

### LinkedList

| 方法名                    | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| public void addFirst(E e) | 在该列表开头插入指定的元素                                   |
| public void addLast(E e)  | 将指定的元素追加到此列表的末尾                               |
| public E getFirst()       | 返回此列表中的第一个元素                                     |
| public E getLast()        | 返回此列表中的最后一个元素                                   |
| int indexOf(Object o)     | 返回此列表中指定元素第一次出现时的索引，没有此元素则返回-1   |
| int lastIndexOf(Object o) | 返回此列表中指定元素最后一次出现时的索引，没有此元素则返回-1 |
| public E removeFirst()    | 从此列表中删除并返回第一个元素                               |
| public E removeLast()     | 从此列表中删除并返回最后一个元素                             |

## 集合的遍历

**Collection集合没有按照索引查看元素的方法，所以不能使用普通for循环遍历元素**，只能通过下面的两个方法：

- 迭代器
- 增强for循环

List集合有一个get()方法，可以根据索引获取元素，所以有三种方法遍历：

- 迭代器
- 普通for循环
- 增强for循环

### 迭代器

迭代器的介绍

- 迭代器，集合的专用遍历方式
- Iterator<E> iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到
- hasNext()检测集合中是否还有下一个元素
- next()返回集合中的下一个元素

Collection集合的遍历

```java
public class IteratorDemo {
    public static void main(String[] args) {
        //创建集合对象
        Collection<String> c = new ArrayList<String>();//使用了泛型就只能接受String对象，如果不写，那么可以接受全部的数据类型，但是容易出现ClassCastException

        //添加元素
        Collecions.addAll(c,"hello","world","java","javaee");

        //Iterator<E> iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到
        Iterator<String> it = c.iterator();

        //用while循环改进元素的判断和获取
        while (it.hasNext()) {
            String s = it.next();
            System.out.println(s);
        }
        
        //改成这种写法更好，节省内存，Iterator对象用完就删除了
        for(Iterator<String> it = c.iterator();it.hasNext();){
            String s = it.next();
            System.out.println(s);
        }
    }
}
```

ListIterator：

* 通过List集合的listIterator()方法得到，所以说它是List集合特有的迭代器

- 用于允许程序员沿任一方向遍历的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置

```java
public class ListIteratorDemo {
    public static void main(String[] args) {
        //创建集合对象
        List<String> list = new ArrayList<String>();

        //添加元素
        list.add("hello");
        list.add("world");
        list.add("java");

        //获取列表迭代器
        ListIterator<String> lit = list.listIterator();
        while (lit.hasNext()) {
            String s = lit.next();
            if(s.equals("world")) {//如果这里用Iterator会出现并发修改异常
                lit.add("javaee");
            }
        }
        System.out.println(list);
    }
}
```

### 增强for循环

JDK5之后引入，本质是调用Iterator迭代器。

```java
public class ForDemo {
    public static void main(String[] args) {
        int[] arr = {1,2,3,4,5};
        for(int i : arr) {
            System.out.println(i);
        }
        
        System.out.println("--------");

        String[] strArray = {"hello","world","java"};
        for(String s : strArray) {
            System.out.println(s);
        }
        
        System.out.println("--------");

        List<String> list = new ArrayList<String>();
        list.add("hello");
        list.add("world");
        list.add("java");

        for(String s : list) {
            System.out.println(s);
        }
        
        System.out.println("--------");

        //内部原理是一个Iterator迭代器
        /*
        for(String s : list) {
            if(s.equals("world")) {
                list.add("javaee"); //ConcurrentModificationException
            }
        }
        */
    }
}
```

### 并发修改异常

代码分析：

```java
public class ListDemo {
    public static void main(String[] args) {
        //创建集合对象
        List<String> list = new ArrayList<String>();
        //添加元素
        list.add("hello");
        list.add("world");
        list.add("java");
        //遍历集合，得到每一个元素，看有没有"world"这个元素，如果有就删除掉这个元素
          Iterator<String> it = list.iterator();
          while (it.hasNext()) {
               String s = it.next();
               if(s.equals("world")) {
                list.remove(s);//抛出并发修改异常ConcurrentModificationException
             }
           }
        //输出集合对象
        System.out.println(list);
    }
}
```

出现异常的原因是集合中删除了元素会导致迭代器预期的迭代次数发生改变，导致迭代器的结果不准确。
为了解决上述问题，可以采用两种方式：

```java
//第一种方式：从业务逻辑上只想将"world"删除，至于后面还有多少字符串并不需要关心，只需找到”world“后跳出循环不再迭代即可，也就是在删除字符串的代码下加一个break就可以了。
while (it.hasNext()) {
      String s = it.next();
       if(s.equals("world")) {
       list.remove(s);
       break;
}
//如果需要在集合的迭代期间对集合中的元素进行删除，可以使用迭代器本身的删除方法，将list.remove()换成it.remove()即可解决这个问题
while (it.hasNext()) {
      String s = it.next();
       if(s.equals("world")) {
       it.remove();
}    
```

## Map

```java
interface Map<K,V>  K：键的类型；V：值的类型
```

Map集合的特点

- 键值对映射关系，一个键对应一个值
- 键不能重复，值可以重复
- 元素存取无序

| 方法名                              | 说明                                 |
| ----------------------------------- | ------------------------------------ |
| V   put(K key,V   value)            | 添加元素                             |
| V   remove(Object key)              | 根据键删除键值对元素                 |
| void   clear()                      | 移除所有的键值对元素                 |
| boolean containsKey(Object key)     | 判断集合是否包含指定的键             |
| boolean containsValue(Object value) | 判断集合是否包含指定的值             |
| boolean isEmpty()                   | 判断集合是否为空                     |
| int size()                          | 集合的长度，也就是集合中键值对的个数 |
| V get(Object key)                   | 根据键获取值                         |
| Set<K> keySet()                     | 获取所有键的集合                     |
| Collection<V>  values()             | 获取所有值的集合                     |
| Set<Map.Entry<K,V>> entrySet()      | 获取所有键值对对象的集合             |

### HashMap

Map的实现类。当hash冲突时，相同hash值的元素会保存在红黑树中（jdk8）。

### LinkedHashMap和LRU

`LRU` 英文全称是 `Least Recently Used`，英译过来就是”**最近最少使用“的意思。** 它是页面置换算法中的一种，在手机清理内存页面，首先展示的就是最近使用的程序，这里用到了LRU缓存算法。

实现 LRU 算法，需要一个HashMap和一个双端链表。LinkedHashMap实现了这个结构。

### Map的遍历

- 方法一：通过keySet得到所有key的集合，然后通过get方法得到key对应的value。

- 方法二：通过entrySet方法获取每一个键值对，Map.EntrySet<K,V>是定义在Map中的一个内部接口，代表键值对。

### HashTable 和 Properties

Map接口中还有一个实现类Hashtable，它和HashMap十分相似，区别在于Hashtable是线程安全的。Hashtable存取元素时速度很慢，目前基本上被HashMap类所取代，但Hashtable类有一个子类Properties非常重要。Properties主要用来存储字符串类型的键和值，在实际开发中，经常使用Properties集合来存取应用的配置项。
详见IO流。

## Set

- Set集合的特点
  - 元素存取无序
  - 没有索引、只能通过迭代器或增强for循环遍历（因为存储的顺序和添加的顺序不一样）
  - 不能存储重复元素（自定义的类型必须重写hashCode和equals方法)
  - 相较于Collection没有任何新增方法
  - 有以下实现类：HashSet是基于HashMap的，HashMap基于哈希表，无序；LinkedHashSet基于HashMap，内部还有一个链表记录了添加的顺序，有序；TreeSet是基于TreeMap的，TreeMap基于红黑树，自然排序。
- Set集合的基本使用

```java
import java.util.HashSet;
import java.util.Set;

public class SetTest {
    //Set是一个接口，必须使用多态创建对象
    public static void main(String[] args) {
        Set<String> set = new HashSet<String>();

        set.add("Hello");
        set.add("World");
        set.add("Java");

        //Set不包含重复元素
        set.add("Hello");
        //Set集合存储的顺序会变
        System.out.println(set);

    }
}
/*console:
[Java, Hello, World]
 */
```

### 哈希值

​	是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值

- 如何获取哈希值

  ​	Object类中的public int hashCode()：返回对象的哈希码值

- 哈希值的特点

  - 同一个对象多次调用hashCode()方法返回的哈希值是相同的
  - 默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同

```java
package CollectionDemo;

public class HashCodeTest {
    public static void main(String[] args) {
        String s1 = "Hello";
        String s2 = "World";
        String s3 = "Hello";
        System.out.println(s1.hashCode());//69609650
        System.out.println(s2.hashCode());//83766130
        System.out.println(s3.hashCode());//69609650

        System.out.println("重地".hashCode());//1179395
        System.out.println("通话".hashCode());//1179395
    }
}

```

### HashSet

- HashSet集合的特点

  - 底层数据结构是HashMap
  - 对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致
  - 没有带索引的方法，所以不能使用普通for循环遍历
  - 由于是Set集合，所以是不包含重复元素的集合

```java
public class HashSetDemo01 {
    public static void main(String[] args) {
        //创建集合对象
        HashSet<String> hs = new HashSet<String>();

        //添加元素
        hs.add("hello");
        hs.add("world");
        hs.add("java");

        hs.add("world");

        //遍历
        for(String s : hs) {
            System.out.println(s);
        }
    }
}
```

HashSet集合保证元素唯一性的图解
![](19.Java集合框架.assets/34234234.png)

Java提供的类可以直接存储成HashSet对象类，但是自己定义的类要重写hashCode方法和equals方法，才能使用，idea可以自动生成这两个函数。

### LinkedHashSet

LinkedHashSet集合特点

- 在HashSet基础上多了一个链表，此链表记录元素存储的顺序，所以LinkedHashSet是有序的
- 由链表保证元素有序，也就是说元素的存储和取出顺序是一致的
- 由哈希表保证元素唯一，也就是说没有重复的元素

```java
import java.util.LinkedHashSet;

public class LinkedHashSetDemo {
    public static void main(String[] args) {
        LinkedHashSet<String> lhs = new LinkedHashSet<String>();

        lhs.add("Hello");
        lhs.add("world");
        lhs.add("java");

        lhs.add("world");
        for(String s : lhs){
            System.out.println(s);
        }
    }
}
```

## Set集合排序

集合的排序可以使用 Collections.sort() 方法，但前提是集合对象实现了比较器接口。
也可以使用TreeSet集合，此集合会自动排序。这个集合对于基本数据类型默认采用自然排序，也可以传入外部比较器改变默认排序的方式。

### 比较器接口Comparable和Comparator

* 内部比较器：Comparable<E>接口中有一个抽象方法compareTo，任何类只要重写了这个方法就可以排序了，称为自然排序。常见的包装类都重写了此方法。因为此方法写在类的内部，所以是内部比较器。

  ```java
  Double a = 1.2;
  Double b = 1.9;
  System.out.println(a.compareTo(b));//返回-1表示前者小于后者，返回0表示二者相等，返回1表示前者大于后者。
  ```

  自定义类重写内部比较器：

  ```java
  class Student implements Comparable<Student>{
      public int age;//年龄
      public double height;//身高
      public Student(int age,double height){
  		this.age = age;
          this.height = height;
  	}
  }	
  	//如果使用的是TreeSet类接收Student对象，只要重写了compareTo就不用重写equals和hashCode方法了. 如果用HashSet接收，就还得重写equals和hashCode方法。
      public int compareTo(Student s){
          //按照身高进行比较
          return ((Double)(this.height)).compareTo((Double)s.height);//Double类重写了compareTo方法，直接调用即可
          //return new Double(this.height-s.height).intValue()
          //按照年龄进行比较，下面是降序排列
          //return s.age - this.age;
      }
  
  ```

* 外部比较器：Comparator<E>接口的抽象方法compare可以接收两个对象进行比较，此方法定义在实体类的外面，所以是外部比较器，又称比较器排序。

  ```java
  //外部比较器的实现类
  public class BiJiao implements Comparator<Student>{
      public int compare(Student s1,s2){
          //先比较年龄，年龄相同就比较身高，都相同TreeSet只会添加一个元素
          if(s1.age != s2.age){
              return s1.age - s2.age;
          }else(s1.height != s2.height){
              return ((Double)s1.height).compareTo((Double).s2.height);
          }
          //也可以用下面这种方法写
          //int num = s1.age - s2.age;
          //int num2 = num==0?((Double)s1.height).compareTo((Double).s2.height):num;
          //return num2;
      }
  }
  ```
  
* 外部比较器和内部比较器谁好？
  外部好，因为外部比较器用到了多态，扩展性好，可以依据想要的排序方式选择不同的比较器。

### TreeSet

- TreeSet集合概述（底层是一个二叉树）

  - 元素有序，具体排序方式取决于构造方法
    - TreeSet()：默认升序排序（包装类有内部比较器，所以不用指定比较器了）
    - TreeSet(Comparator comparator) ：根据指定的比较器进行排序（自定义数据类型必须传入外部比较器）
  - 没有带索引的方法，所以不能使用普通for循环遍历
  - 由于是Set集合，所以不包含重复元素的集合。通过比较器实现的无重复元素，用不着重写hashCode和equals了。

- TreeSet集合基本使用

  ```java
  public class TreeSetDemo01 {
      public static void main(String[] args) {
          //创建集合对象
          TreeSet<Integer> ts = new TreeSet<Integer>();
  
          //添加元素
          ts.add(10);
          ts.add(40);
          ts.add(30);
          ts.add(50);
          ts.add(20);
  		//添加重复元素
          ts.add(30);
  
          //遍历集合
          for(Integer i : ts) {
              System.out.println(i);
          }
      }
  }
  ```

- 案例需求

  - 存储学生对象并遍历，按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序

- 实现步骤

  - 用TreeSet集合存储自定义对象，无参构造方法使用的是内部比较器
  - 内部比较器就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法
  - TreeSet有参构造使用的是外部构造器
  - 外部构造器就是Comparator<>的一个实现类，重写了compare方法。

- 代码实现

  - 学生类

    ```java
    public class Student implements Comparable<Student> {
        private int age;
        private String name;
    
        public Student(){}
        public Student(String name,int age){
            this.name = name;
            this.age = age;
        }
    
        public int getAge() {
            return age;
        }
        public void setAge(int age) {
            this.age = age;
        }
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
    
        //重写hashCode和equal方法，确保元素不重复
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Student student = (Student) o;
            return age == student.age && name.equals(student.name);
        }
        @Override
        public int hashCode() {
            return Objects.hash(age, name);
        }
    
        //重写内部比较器compareTo方法，确保元素有序
        @Override
        public int compareTo(Student o) {
            //先比较年龄，年龄相同比较姓名
            if(this.getAge() != o.getAge()){
                return this.getAge()-o.getAge();
            }else{
                return this.getName().compareTo(o.getName());
            }
        }
    
        @Override
        public String toString() {
            return "Student{" +
                    "age=" + age +
                    ", name='" + name + '\'' +
                    '}';
        }
    }
    ```
    
  - 外部比较器
  
    ```java
    public class ComparatorDemo01 implements Comparator<Student> {
    
        @Override
        public int compare(Student o1, Student o2) {
            if(o1.getAge() != o2.getAge()){
                return ((Integer)o1.getAge()).compareTo((Integer)o2.getAge());
            }else{
                return o1.getName().compareTo(o2.getName());
            }
        }
    }
    ```
    
  - 测试类
  
    ```java
    package CollectionDemo;
    
    import java.util.Comparator;
    import java.util.TreeSet;
    
    public class StudentTest {
        public static void main(String[] args) {
            /*//创建外部比较器
            Comparator<Student> com = new ComparatorDemo01();
            //传入外部比较器
            TreeSet<Student> students = new TreeSet<Student>(com);*/
    
            /*//使用内部比较器
            TreeSet<Student> students = new TreeSet<>();*/
    
            //使用匿名内部类创建外部比较器
            TreeSet<Student> students = new TreeSet<>(new Comparator<Student>(){
                @Override
                public int compare(Student o1, Student o2) {
                    if(o1.getAge() != o2.getAge()){
                        return ((Integer)o1.getAge()).compareTo((Integer)o2.getAge());
                    }else{
                        return o1.getName().compareTo(o2.getName());
                    }
                }
            });
    
            Student s1 = new Student("Jack",20);
            Student s2 = new Student("Tom",32);
            Student s3 = new Student("Mary",23);
            Student s4 = new Student("Mary",23);
            Student s5 = new Student("Tony",23);
    
            students.add(s1);
            students.add(s2);
            students.add(s3);
            students.add(s4);
            students.add(s5);
    
            for(Student s : students){
                System.out.println(s.getAge()+","+s.getName());
            }
    
            System.out.println(students);
        }
    }
    ```

## Collections工具类

| 方法名                                                | 说明                               |
| ----------------------------------------------------- | ---------------------------------- |
| public static void sort(List<T> list)                 | 将指定的列表按升序排序             |
| public static void sort(List<T> list, Comparator com) | 使用指定的外部比较器排序           |
| public static void reverse(List<?> list)              | 反转指定列表中元素的顺序           |
| public static void shuffle(List<?> list)              | 使用默认的随机源随机排列指定的列表 |
| boolean addAll(Collection c,值1,值2,... )             | 将所有指定的元素添加到指定的集合   |

- 示例代码

  ```java
  public class CollectionsDemo01 {
      public static void main(String[] args) {
          //创建集合对象
          List<Integer> list = new ArrayList<Integer>();
  
          //添加元素
          list.add(30);
          list.add(20);
          list.add(50);
          list.add(10);
          list.add(40);
  
          //public static <T extends Comparable<? super T>> void sort(List<T> list)：将指定的列表按升序排序
  //        Collections.sort(list);
  
          //public static void reverse(List<?> list)：反转指定列表中元素的顺序
  //        Collections.reverse(list);
  
          //public static void shuffle(List<?> list)：使用默认的随机源随机排列指定的列表
          Collections.shuffle(list);
  
          System.out.println(list);
      }
  }
  ```

